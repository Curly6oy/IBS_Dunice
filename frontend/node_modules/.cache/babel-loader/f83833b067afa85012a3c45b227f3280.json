{"ast":null,"code":"/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)\n * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)\n * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.\n *\n * Version: 1.3.8\n *\n */\n(function ($) {\n  $.fn.extend({\n    slimScroll: function slimScroll(options) {\n      var defaults = {\n        // width in pixels of the visible scroll area\n        width: 'auto',\n        // height in pixels of the visible scroll area\n        height: '250px',\n        // width in pixels of the scrollbar and rail\n        size: '7px',\n        // scrollbar color, accepts any hex/color value\n        color: '#000',\n        // scrollbar position - left/right\n        position: 'right',\n        // distance in pixels between the side edge and the scrollbar\n        distance: '1px',\n        // default scroll position on load - top / bottom / $('selector')\n        start: 'top',\n        // sets scrollbar opacity\n        opacity: .4,\n        // enables always-on mode for the scrollbar\n        alwaysVisible: false,\n        // check if we should hide the scrollbar when user is hovering over\n        disableFadeOut: false,\n        // sets visibility of the rail\n        railVisible: false,\n        // sets rail color\n        railColor: '#333',\n        // sets rail opacity\n        railOpacity: .2,\n        // whether  we should use jQuery UI Draggable to enable bar dragging\n        railDraggable: true,\n        // defautlt CSS class of the slimscroll rail\n        railClass: 'slimScrollRail',\n        // defautlt CSS class of the slimscroll bar\n        barClass: 'slimScrollBar',\n        // defautlt CSS class of the slimscroll wrapper\n        wrapperClass: 'slimScrollDiv',\n        // check if mousewheel should scroll the window if we reach top/bottom\n        allowPageScroll: false,\n        // scroll amount applied to each mouse wheel step\n        wheelStep: 20,\n        // scroll amount applied when user is using gestures\n        touchScrollStep: 200,\n        // sets border radius\n        borderRadius: '7px',\n        // sets border radius of the rail\n        railBorderRadius: '7px'\n      };\n      var o = $.extend(defaults, options); // do it for every element that matches selector\n\n      this.each(function () {\n        var isOverPanel,\n            isOverBar,\n            isDragg,\n            queueHide,\n            touchDif,\n            barHeight,\n            percentScroll,\n            lastScroll,\n            divS = '<div></div>',\n            minBarHeight = 30,\n            releaseScroll = false; // used in event handlers and for better minification\n\n        var me = $(this); // ensure we are not binding it again\n\n        if (me.parent().hasClass(o.wrapperClass)) {\n          // start from last bar position\n          var offset = me.scrollTop(); // find bar and rail\n\n          bar = me.siblings('.' + o.barClass);\n          rail = me.siblings('.' + o.railClass);\n          getBarHeight(); // check if we should scroll existing instance\n\n          if ($.isPlainObject(options)) {\n            // Pass height: auto to an existing slimscroll object to force a resize after contents have changed\n            if ('height' in options && options.height == 'auto') {\n              me.parent().css('height', 'auto');\n              me.css('height', 'auto');\n              var height = me.parent().parent().height();\n              me.parent().css('height', height);\n              me.css('height', height);\n            } else if ('height' in options) {\n              var h = options.height;\n              me.parent().css('height', h);\n              me.css('height', h);\n            }\n\n            if ('scrollTo' in options) {\n              // jump to a static point\n              offset = parseInt(o.scrollTo);\n            } else if ('scrollBy' in options) {\n              // jump by value pixels\n              offset += parseInt(o.scrollBy);\n            } else if ('destroy' in options) {\n              // remove slimscroll elements\n              bar.remove();\n              rail.remove();\n              me.unwrap();\n              return;\n            } // scroll content by the given offset\n\n\n            scrollContent(offset, false, true);\n          }\n\n          return;\n        } else if ($.isPlainObject(options)) {\n          if ('destroy' in options) {\n            return;\n          }\n        } // optionally set height to the parent's height\n\n\n        o.height = o.height == 'auto' ? me.parent().height() : o.height; // wrap content\n\n        var wrapper = $(divS).addClass(o.wrapperClass).css({\n          position: 'relative',\n          overflow: 'hidden',\n          width: o.width,\n          height: o.height\n        }); // update style for the div\n\n        me.css({\n          overflow: 'hidden',\n          width: o.width,\n          height: o.height\n        }); // create scrollbar rail\n\n        var rail = $(divS).addClass(o.railClass).css({\n          width: o.size,\n          height: '100%',\n          position: 'absolute',\n          top: 0,\n          display: o.alwaysVisible && o.railVisible ? 'block' : 'none',\n          'border-radius': o.railBorderRadius,\n          background: o.railColor,\n          opacity: o.railOpacity,\n          zIndex: 90\n        }); // create scrollbar\n\n        var bar = $(divS).addClass(o.barClass).css({\n          background: o.color,\n          width: o.size,\n          position: 'absolute',\n          top: 0,\n          opacity: o.opacity,\n          display: o.alwaysVisible ? 'block' : 'none',\n          'border-radius': o.borderRadius,\n          BorderRadius: o.borderRadius,\n          MozBorderRadius: o.borderRadius,\n          WebkitBorderRadius: o.borderRadius,\n          zIndex: 99\n        }); // set position\n\n        var posCss = o.position == 'right' ? {\n          right: o.distance\n        } : {\n          left: o.distance\n        };\n        rail.css(posCss);\n        bar.css(posCss); // wrap it\n\n        me.wrap(wrapper); // append to parent div\n\n        me.parent().append(bar);\n        me.parent().append(rail); // make it draggable and no longer dependent on the jqueryUI\n\n        if (o.railDraggable) {\n          bar.bind(\"mousedown\", function (e) {\n            var $doc = $(document);\n            isDragg = true;\n            t = parseFloat(bar.css('top'));\n            pageY = e.pageY;\n            $doc.bind(\"mousemove.slimscroll\", function (e) {\n              currTop = t + e.pageY - pageY;\n              bar.css('top', currTop);\n              scrollContent(0, bar.position().top, false); // scroll content\n            });\n            $doc.bind(\"mouseup.slimscroll\", function (e) {\n              isDragg = false;\n              hideBar();\n              $doc.unbind('.slimscroll');\n            });\n            return false;\n          }).bind(\"selectstart.slimscroll\", function (e) {\n            e.stopPropagation();\n            e.preventDefault();\n            return false;\n          });\n        } // on rail over\n\n\n        rail.hover(function () {\n          showBar();\n        }, function () {\n          hideBar();\n        }); // on bar over\n\n        bar.hover(function () {\n          isOverBar = true;\n        }, function () {\n          isOverBar = false;\n        }); // show on parent mouseover\n\n        me.hover(function () {\n          isOverPanel = true;\n          showBar();\n          hideBar();\n        }, function () {\n          isOverPanel = false;\n          hideBar();\n        }); // support for mobile\n\n        me.bind('touchstart', function (e, b) {\n          if (e.originalEvent.touches.length) {\n            // record where touch started\n            touchDif = e.originalEvent.touches[0].pageY;\n          }\n        });\n        me.bind('touchmove', function (e) {\n          // prevent scrolling the page if necessary\n          if (!releaseScroll) {\n            e.originalEvent.preventDefault();\n          }\n\n          if (e.originalEvent.touches.length) {\n            // see how far user swiped\n            var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep; // scroll content\n\n            scrollContent(diff, true);\n            touchDif = e.originalEvent.touches[0].pageY;\n          }\n        }); // set up initial height\n\n        getBarHeight(); // check start position\n\n        if (o.start === 'bottom') {\n          // scroll content to bottom\n          bar.css({\n            top: me.outerHeight() - bar.outerHeight()\n          });\n          scrollContent(0, true);\n        } else if (o.start !== 'top') {\n          // assume jQuery selector\n          scrollContent($(o.start).position().top, null, true); // make sure bar stays hidden\n\n          if (!o.alwaysVisible) {\n            bar.hide();\n          }\n        } // attach scroll events\n\n\n        attachWheel(this);\n\n        function _onWheel(e) {\n          // use mouse wheel only when mouse is over\n          if (!isOverPanel) {\n            return;\n          }\n\n          var e = e || window.event;\n          var delta = 0;\n\n          if (e.wheelDelta) {\n            delta = -e.wheelDelta / 120;\n          }\n\n          if (e.detail) {\n            delta = e.detail / 3;\n          }\n\n          var target = e.target || e.srcTarget || e.srcElement;\n\n          if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {\n            // scroll content\n            scrollContent(delta, true);\n          } // stop window scroll\n\n\n          if (e.preventDefault && !releaseScroll) {\n            e.preventDefault();\n          }\n\n          if (!releaseScroll) {\n            e.returnValue = false;\n          }\n        }\n\n        function scrollContent(y, isWheel, isJump) {\n          releaseScroll = false;\n          var delta = y;\n          var maxTop = me.outerHeight() - bar.outerHeight();\n\n          if (isWheel) {\n            // move bar with mouse wheel\n            delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight(); // move bar, make sure it doesn't go out\n\n            delta = Math.min(Math.max(delta, 0), maxTop); // if scrolling down, make sure a fractional change to the\n            // scroll position isn't rounded away when the scrollbar's CSS is set\n            // this flooring of delta would happened automatically when\n            // bar.css is set below, but we floor here for clarity\n\n            delta = y > 0 ? Math.ceil(delta) : Math.floor(delta); // scroll the scrollbar\n\n            bar.css({\n              top: delta + 'px'\n            });\n          } // calculate actual scroll amount\n\n\n          percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());\n          delta = percentScroll * (me[0].scrollHeight - me.outerHeight());\n\n          if (isJump) {\n            delta = y;\n            var offsetTop = delta / me[0].scrollHeight * me.outerHeight();\n            offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);\n            bar.css({\n              top: offsetTop + 'px'\n            });\n          } // scroll content\n\n\n          me.scrollTop(delta); // fire scrolling event\n\n          me.trigger('slimscrolling', ~~delta); // ensure bar is visible\n\n          showBar(); // trigger hide when scroll is stopped\n\n          hideBar();\n        }\n\n        function attachWheel(target) {\n          if (window.addEventListener) {\n            target.addEventListener('DOMMouseScroll', _onWheel, false);\n            target.addEventListener('mousewheel', _onWheel, false);\n          } else {\n            document.attachEvent(\"onmousewheel\", _onWheel);\n          }\n        }\n\n        function getBarHeight() {\n          // calculate scrollbar height and make sure it is not too small\n          barHeight = Math.max(me.outerHeight() / me[0].scrollHeight * me.outerHeight(), minBarHeight);\n          bar.css({\n            height: barHeight + 'px'\n          }); // hide scrollbar if content is not long enough\n\n          var display = barHeight == me.outerHeight() ? 'none' : 'block';\n          bar.css({\n            display: display\n          });\n        }\n\n        function showBar() {\n          // recalculate bar height\n          getBarHeight();\n          clearTimeout(queueHide); // when bar reached top or bottom\n\n          if (percentScroll == ~~percentScroll) {\n            //release wheel\n            releaseScroll = o.allowPageScroll; // publish approporiate event\n\n            if (lastScroll != percentScroll) {\n              var msg = ~~percentScroll == 0 ? 'top' : 'bottom';\n              me.trigger('slimscroll', msg);\n            }\n          } else {\n            releaseScroll = false;\n          }\n\n          lastScroll = percentScroll; // show only when required\n\n          if (barHeight >= me.outerHeight()) {\n            //allow window scroll\n            releaseScroll = true;\n            return;\n          }\n\n          bar.stop(true, true).fadeIn('fast');\n\n          if (o.railVisible) {\n            rail.stop(true, true).fadeIn('fast');\n          }\n        }\n\n        function hideBar() {\n          // only hide when options allow it\n          if (!o.alwaysVisible) {\n            queueHide = setTimeout(function () {\n              if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg) {\n                bar.fadeOut('slow');\n                rail.fadeOut('slow');\n              }\n            }, 1000);\n          }\n        }\n      }); // maintain chainability\n\n      return this;\n    }\n  });\n  $.fn.extend({\n    slimscroll: $.fn.slimScroll\n  });\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}